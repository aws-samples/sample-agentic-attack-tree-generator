"""File generation for summary reports"""
import json
from typing import Dict, Any, List, Optional
from pathlib import Path
from datetime import datetime
from .report_formatters import ReportFormatters


class PathEncoder(json.JSONEncoder):
    """Custom JSON encoder to handle Path objects"""
    def default(self, obj):
        if isinstance(obj, Path):
            return str(obj)
        return super().default(obj)


class FileGenerators:
    """Generates report files"""
    
    def __init__(self, logger, formatters: ReportFormatters):
        self.logger = logger
        self.fmt = formatters
        self.mitigation_mapper = None
        self._init_mitigation_mapper()
    
    def _init_mitigation_mapper(self):
        """Initialize mitigation mapper if STIX bundle is available"""
        try:
            from threatforest.config import config
            from threatforest.modules.workflow.ttc_mappings import MitigationMapper
            
            if config.stix_bundle_path and Path(config.stix_bundle_path).exists():
                self.mitigation_mapper = MitigationMapper(str(config.stix_bundle_path))
                self.logger.info(f"Mitigation mapper initialized with STIX bundle")
            else:
                self.logger.warning(f"STIX bundle not found, mitigations will not be included")
        except Exception as e:
            self.logger.warning(f"Could not initialize mitigation mapper: {e}")
            self.mitigation_mapper = None
    
    def generate_main_summary(self, output_path: Path, attack_trees: Dict, extracted_info: Dict) -> str:
        """Generate main summary report"""
        project_info = extracted_info.get('project_info', {})
        extraction_summary = extracted_info.get('extraction_summary', {})
        
        trees = attack_trees.get('ttc_mapped_trees', []) or attack_trees.get('attack_trees', [])
        successful = [t for t in trees if 'mermaid_code' in t]
        failed = [t for t in trees if 'error' in t]
        
        content = f"""# ThreatForest Analysis Report

**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary

This report presents a comprehensive threat analysis for **{project_info.get('application_name', 'Unknown Application')}**.

## Project Information

- **Application Name**: {project_info.get('application_name', 'Unknown')}
- **Architecture Type**: {project_info.get('architecture_type', 'Unknown')}
- **Deployment Environment**: {project_info.get('deployment_environment', 'Unknown')}
- **Industry Sector**: {project_info.get('sector', 'Unknown')}

### Technology Stack
{self.fmt.format_technologies(project_info.get('technologies', []))}

### Security Objectives
{self.fmt.format_security_objectives(project_info.get('security_objectives', []))}

## Threat Analysis Results

- **Total Threats**: {extraction_summary.get('total_threats', 0)}
- **High Severity**: {extraction_summary.get('high_severity_count', 0)}
- **Attack Trees Generated**: {len(successful)}

### High Severity Threats
{self.fmt.format_high_severity_threats(extracted_info.get('high_severity_threats', []))}

## Attack Tree Analysis

### Generated Attack Trees
{self.fmt.format_attack_trees_summary(successful)}

{self.fmt.format_failed_trees(failed)}

## Recommendations

1. **Address High Severity Threats**: Focus on the {extraction_summary.get('high_severity_count', 0)} high severity threats
2. **Implement Security Controls**: Deploy mitigations from attack trees
3. **Review Attack Paths**: Analyze generated attack trees

---
*Generated by ThreatForest*
"""
        
        summary_file = output_path / "threatforest_analysis_report.md"
        summary_file.write_text(content)
        return str(summary_file)
    
    def generate_attack_tree_files(self, output_path: Path, trees: List[Dict]) -> List[str]:
        """Generate individual attack tree markdown files with TTC mappings"""
        tree_files = []
        
        for tree in trees:
            if not isinstance(tree, dict) or 'mermaid_code' not in tree:
                continue
            
            threat_id = tree.get('threat_id', 'unknown')
            threat_statement = tree.get('threat_statement', tree.get('statement', ''))
            category = tree.get('threat_category', tree.get('category', 'Unknown'))
            
            filename = f"attack_tree_{threat_id}_{category.lower().replace(' ', '_')}.md"
            file_path = output_path / filename
            
            # Build TTC mapping section if available
            ttc_section = self._build_ttc_section(tree)
            
            content = f"""# Attack Tree: {category}

**Threat ID**: {threat_id}
**Statement**: {threat_statement}

## Attack Tree Diagram

```mermaid
{tree.get('mermaid_code', '')}
```

{ttc_section}

## Attack Path Analysis

Review this attack tree to:
1. Identify critical attack paths
2. Implement appropriate security controls
3. Monitor for indicators
4. Develop incident response procedures

---
*Generated by ThreatForest*
"""
            
            try:
                file_path.write_text(content, encoding='utf-8')
                tree_files.append(str(file_path))
                self.logger.info(f"Generated: {filename}")
            except Exception as e:
                self.logger.warning(f"Failed to write {filename}: {e}")
        
        return tree_files
    
    def _build_ttc_section(self, tree: Dict) -> str:
        """Build MITRE ATT&CK mapping section for attack tree with mitigations"""
        # TTC mappings are stored in a separate array at the tree level
        ttc_mappings = tree.get('ttc_mappings', [])
        
        if not ttc_mappings:
            return ""
        
        ttc_content = "\n## MITRE ATT&CK Mapping\n\n"
        ttc_content += "This attack tree has been mapped to MITRE ATT&CK techniques:\n\n"
        
        total_mitigations = 0
        
        for idx, mapping in enumerate(ttc_mappings, 1):
            attack_step = mapping.get('attack_step', 'Unknown')
            technique_id = mapping.get('technique_id', '')
            technique_name = mapping.get('technique_name', '')
            confidence = mapping.get('confidence', 0.0)
            tactics = mapping.get('tactics', [])
            
            # Clean up technique ID (remove duplicates like "T1190,T1190")
            if ',' in technique_id:
                technique_id = technique_id.split(',')[0]
            
            ttc_content += f"### {attack_step}\n\n"
            
            # Format technique with link
            technique_link = technique_id.replace('.', '/')
            ttc_content += f"- **Technique**: [{technique_id}](https://attack.mitre.org/techniques/{technique_link}/)"
            
            if technique_name:
                ttc_content += f" - {technique_name}"
            ttc_content += "\n"
            
            # Add tactics
            if tactics:
                tactics_str = ", ".join([t.replace('-', ' ').title() for t in tactics])
                ttc_content += f"- **Tactic**: {tactics_str}\n"
            
            # Add confidence score
            # Cosine similarity should be 0-1 (or up to 1.5 with AWS boost)
            # Values > 1.5 indicate a data issue that needs normalization
            if confidence > 0:
                if confidence > 1.5:
                    # Abnormal score - likely distance metric or unnormalized
                    # Normalize to 0-1 range by treating as inverted distance
                    normalized = 1.0 / (1.0 + confidence / 100.0)
                    ttc_content += f"- **Similarity Score**: {normalized:.2%} (normalized from {confidence:.2f})\n"
                elif confidence > 1.0:
                    # Valid range with AWS boost (1.0-1.5)
                    ttc_content += f"- **Similarity Score**: {confidence:.2%}\n"
                else:
                    # Standard cosine similarity (0-1)
                    ttc_content += f"- **Similarity Score**: {confidence:.2%}\n"
            
            # Add mitigations if available
            if self.mitigation_mapper:
                mitigations = self.mitigation_mapper.get_mitigations(technique_id)
                if mitigations:
                    ttc_content += f"- **Mitigations ({len(mitigations)}):**\n"
                    # Show top 3 mitigations to keep output concise
                    for mit in mitigations[:3]:
                        mit_name = mit.get('name', 'Unknown')
                        mit_desc = mit.get('description', '')
                        
                        ttc_content += f"  - ðŸ›¡ï¸ **{mit_name}**"
                        
                        # Add truncated description
                        if mit_desc:
                            # Clean and truncate description
                            desc_clean = mit_desc.replace('\n', ' ').strip()
                            if len(desc_clean) > 120:
                                desc_clean = desc_clean[:120] + "..."
                            ttc_content += f"\n    {desc_clean}"
                        ttc_content += "\n"
                    
                    total_mitigations += len(mitigations)
                    
                    # Add link to see all mitigations if more than 3
                    if len(mitigations) > 3:
                        ttc_content += f"  - *{len(mitigations) - 3} more mitigation(s) available*\n"
            
            ttc_content += "\n"
        
        # Add mapping summary
        summary_text = f"\n*Total technique mappings: {len(ttc_mappings)}"
        if total_mitigations > 0:
            summary_text += f" | Mitigations found: {total_mitigations}"
        summary_text += "*\n"
        ttc_content += summary_text
        
        return ttc_content
    
    def generate_json_export(self, output_path: Path, attack_trees: Dict, extracted_info: Dict) -> str:
        """Generate JSON data export"""
        trees = attack_trees.get('ttc_mapped_trees', []) or attack_trees.get('attack_trees', [])
        
        export_data = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "generator": "ThreatForest",
                "version": "1.0"
            },
            "project_info": extracted_info.get('project_info', {}),
            "extraction_summary": extracted_info.get('extraction_summary', {}),
            "threats": {
                "all_threats": extracted_info.get('threat_statements', []),
                "high_severity": extracted_info.get('high_severity_threats', [])
            },
            "attack_trees": trees,
            "mapping_summary": attack_trees.get('mapping_summary', {})
        }
        
        json_file = output_path / "threatforest_data.json"
        with open(json_file, 'w') as f:
            json.dump(export_data, f, indent=2, cls=PathEncoder)
        
        return str(json_file)
    
    def generate_html_visualizations(self, output_path: Path, trees: List[Dict] = None, extracted_info: Dict = None) -> List[str]:
        """
        Generate unified HTML dashboard from structured tree data
        
        Args:
            output_path: Directory to save HTML dashboard
            trees: List of tree dictionaries with TTC mappings (from TTC mapper)
            extracted_info: Optional extracted information for executive summary
            
        Returns:
            List containing the dashboard HTML file path
        """
        from ...visualization import HTMLGenerator
        
        generator = HTMLGenerator()
        
        if not trees:
            self.logger.warning("No tree data provided for HTML generation")
            return []
        
        self.logger.info(f"Generating unified dashboard for {len(trees)} attack trees...")
        
        # Build summary data for executive summary tab
        summary_data = None
        if extracted_info:
            summary_data = {
                'project_info': extracted_info.get('project_info', {}),
                'extraction_summary': extracted_info.get('extraction_summary', {}),
                'high_severity_threats': extracted_info.get('high_severity_threats', [])
            }
            self.logger.info("Executive summary data included in dashboard")
        
        try:
            # Generate unified dashboard from structured data
            dashboard_path = output_path / "attack_trees_dashboard.html"
            generator.generate_dashboard_from_data(
                trees_data=trees,
                output_path=str(dashboard_path),
                summary_data=summary_data
            )
            
            dashboard_type = "with executive summary" if summary_data else "without executive summary"
            self.logger.info(f"âœ“ Generated unified dashboard with {len(trees)} tabs {dashboard_type}")
            return [str(dashboard_path)]
            
        except Exception as e:
            self.logger.error(f"Failed to generate dashboard: {e}")
            return []
