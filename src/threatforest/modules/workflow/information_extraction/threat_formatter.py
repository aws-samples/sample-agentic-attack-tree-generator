"""Threat formatting utilities for creating structured output files"""
import re
from typing import List, Dict, Any, Optional
from pathlib import Path


class ThreatFormatter:
    """Handles formatting and creating threat statement output files"""
    
    def __init__(self, logger):
        """Initialize formatter with logger
        
        Args:
            logger: Logger instance for formatting operations
        """
        self.logger = logger
    
    def extract_threat_category(self, threat_statement: str) -> str:
        """Extract a meaningful category from a threat statement
        
        Args:
            threat_statement: Threat statement text
            
        Returns:
            Threat category string
        """
        statement_lower = threat_statement.lower()
        
        # Common threat categories based on keywords
        if any(word in statement_lower for word in ['inject', 'sql', 'xss', 'script']):
            return 'Injection Attack'
        elif any(word in statement_lower for word in ['authentication', 'login', 'password', 'credential']):
            return 'Authentication'
        elif any(word in statement_lower for word in ['authorization', 'access control', 'privilege']):
            return 'Authorization'
        elif any(word in statement_lower for word in ['encrypt', 'decrypt', 'crypto', 'tls', 'ssl']):
            return 'Cryptography'
        elif any(word in statement_lower for word in ['data breach', 'data leak', 'exfiltrat', 'exposure']):
            return 'Data Breach'
        elif any(word in statement_lower for word in ['denial', 'dos', 'ddos', 'availability']):
            return 'Availability'
        elif any(word in statement_lower for word in ['malware', 'virus', 'trojan', 'backdoor']):
            return 'Malware'
        elif any(word in statement_lower for word in ['social engineering', 'phishing', 'spear']):
            return 'Social Engineering'
        elif any(word in statement_lower for word in ['insider', 'internal', 'employee']):
            return 'Insider Threat'
        elif any(word in statement_lower for word in ['network', 'man-in-the-middle', 'mitm', 'sniff']):
            return 'Network Attack'
        elif any(word in statement_lower for word in ['configuration', 'misconfigur', 'setup']):
            return 'Configuration'
        elif any(word in statement_lower for word in ['supply chain', 'third party', 'vendor']):
            return 'Supply Chain'
        elif any(word in statement_lower for word in ['ai', 'ml', 'model', 'llm', 'prompt']):
            return 'AI/ML Security'
        else:
            return 'Security Threat'
    
    def fix_threat_counts(self, content: str) -> str:
        """Fix threat counts in the header by parsing actual content
        
        Args:
            content: Markdown content with threat statements
            
        Returns:
            Content with corrected counts
        """
        # Count actual threats by priority
        high_count = len(re.findall(r'- \*\*Priority\*\*: High', content))
        medium_count = len(re.findall(r'- \*\*Priority\*\*: Medium', content))
        low_count = len(re.findall(r'- \*\*Priority\*\*: Low', content))
        total_count = high_count + medium_count + low_count
        
        # Update the counts in the header
        content = re.sub(r'- \*\*Total Threats\*\*: \d+', f'- **Total Threats**: {total_count}', content)
        content = re.sub(r'- \*\*High Priority\*\*: \d+', f'- **High Priority**: {high_count}', content)
        content = re.sub(r'- \*\*Medium Priority\*\*: \d+', f'- **Medium Priority**: {medium_count}', content)
        content = re.sub(r'- \*\*Low Priority\*\*: \d+', f'- **Low Priority**: {low_count}', content)
        
        return content
    
    def create_threats_markdown_file(self, threats: List[Dict[str, Any]], project_path: str, 
                                    project_info: Dict[str, Any] = None) -> str:
        """Create a markdown file with generated threat statements
        
        Args:
            threats: List of threat dicts
            project_path: Path to save file
            project_info: Optional project information
            
        Returns:
            Filename of created file
        """
        # Generate filename with application name
        app_name = "Unknown"
        if project_info and project_info.get('application_name'):
            app_name = project_info['application_name']
        
        # Clean application name for filename
        clean_app_name = re.sub(r'[^\w\s-]', '', app_name).strip()
        clean_app_name = re.sub(r'[-\s]+', '_', clean_app_name)
        filename = f"{clean_app_name}_generated_threat_statements.md"
        
        markdown_content = f"""# Generated Threat Statements - {app_name}

*This file was automatically generated by ThreatForest AI analysis.*

## Application Context
- **Application**: {app_name}
- **Generated**: {Path().cwd()}
- **Total Threats**: {len(threats)}
- **High Priority**: {len([t for t in threats if t.get('severity') == 'High'])}
- **Medium Priority**: {len([t for t in threats if t.get('severity') == 'Medium'])}
- **Low Priority**: {len([t for t in threats if t.get('severity') == 'Low'])}

## Threat Statements

"""
        
        # Group threats by priority
        high_threats = [t for t in threats if t.get('severity') == 'High']
        medium_threats = [t for t in threats if t.get('severity') == 'Medium']
        low_threats = [t for t in threats if t.get('severity') == 'Low']
        
        for priority, threat_list in [("High", high_threats), ("Medium", medium_threats), ("Low", low_threats)]:
            if threat_list:
                markdown_content += f"### {priority} Priority Threats\n\n"
                
                for threat in threat_list:
                    markdown_content += f"#### {threat.get('id', 'T000')} - {threat.get('category', 'General')}\n\n"
                    markdown_content += f"**Threat Statement**: {threat.get('statement', '')}\n\n"
                    
                    # Add breakdown if available
                    if threat.get('threatSource'):
                        markdown_content += f"- **Threat Source**: {threat.get('threatSource', '')}\n"
                        markdown_content += f"- **Prerequisites**: {threat.get('prerequisites', '')}\n"
                        markdown_content += f"- **Threat Action**: {threat.get('threatAction', '')}\n"
                        markdown_content += f"- **Threat Impact**: {threat.get('threatImpact', '')}\n"
                        markdown_content += f"- **Reduced Goal**: {threat.get('impactedGoal', '')}\n"
                        markdown_content += f"- **Impacted Assets**: {threat.get('impactedAssets', '')}\n"
                    
                    markdown_content += f"- **Priority**: {priority}\n"
                    markdown_content += f"- **Category**: {threat.get('category', 'General')}\n\n"
                    markdown_content += "---\n\n"
        
        markdown_content += """
## Usage Notes

These threat statements were generated using AI analysis of your application context. They follow the standard threat modeling syntax:

**"A [threat source] with [pre-requisites], can [threat action], which leads to [threat impact], resulting in [reduced goal] of [impacted assets]."**

### Next Steps
1. Review and validate these threat statements
2. Modify or add threats as needed for your specific context
3. Use these threats as input for attack tree generation
4. Consider implementing mitigations for high-priority threats

### Customization
You can edit this file to:
- Add more specific threat statements
- Adjust priority levels
- Include additional context or mitigations
- Remove threats that don't apply to your application
"""
        
        # Write to file
        output_path = Path(project_path) / filename
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        return filename
    
    def create_formatted_threat_file(self, threat_data: Dict[str, Any], source_file: str) -> Optional[str]:
        """Create a formatted threat file from ThreatComposer data
        
        Args:
            threat_data: Parsed threat data from ThreatComposer
            source_file: Original source file path
            
        Returns:
            Path to created file or None on error
        """
        try:
            # Create output filename
            source_path = Path(source_file)
            output_file = source_path.parent / f"{source_path.stem}_generated_threat_statements.md"
            
            # Extract application context
            app_context = threat_data.get('application_context', {})
            app_name = app_context.get('name', 'Unknown Application')
            app_description = app_context.get('description', '')
            technologies = app_context.get('technologies', [])
            
            # Group threats by priority
            threats = threat_data.get('threats', [])
            high_threats = [t for t in threats if t.get('priority', '').lower() == 'high']
            medium_threats = [t for t in threats if t.get('priority', '').lower() == 'medium']
            low_threats = [t for t in threats if t.get('priority', '').lower() == 'low']
            
            # Generate formatted content
            content = f"""# Generated Threat Statements

*This file was automatically generated from ThreatComposer file: {source_path.name}*

## Application Context

**Application Name:** {app_name}

**Description:** {app_description}

**Technologies:** {', '.join(technologies) if technologies else 'Not specified'}

**Total Threats:** {len(threats)}
- **High Priority:** {len(high_threats)}
- **Medium Priority:** {len(medium_threats)}  
- **Low Priority:** {len(low_threats)}

## Threat Statements

"""
            
            # Add threats by priority
            threat_counter = 1
            for priority_level, threat_list in [('high', high_threats), ('medium', medium_threats), ('low', low_threats)]:
                if not threat_list:
                    continue
                    
                priority_title = priority_level.capitalize()
                content += f"### {priority_title} Priority Threats\n\n"
                
                for threat in threat_list:
                    threat_id = f'T{threat_counter:03d}'
                    threat_counter += 1
                    
                    # Extract category from original threat or use generic
                    original_statement = threat.get('statement', 'No statement provided')
                    category = self.extract_threat_category(original_statement)
                    
                    content += f"#### {threat_id} - {category}\n\n"
                    content += f"**Threat Statement**: {original_statement}\n\n"
                    
                    if threat.get('source'):
                        content += f"- **Threat Source**: {threat['source']}\n"
                    if threat.get('prerequisites'):
                        content += f"- **Prerequisites**: {threat['prerequisites']}\n"
                    if threat.get('action'):
                        content += f"- **Threat Action**: {threat['action']}\n"
                    if threat.get('impact'):
                        content += f"- **Threat Impact**: {threat['impact']}\n"
                    if threat.get('impactedGoal'):
                        content += f"- **Reduced Goal**: {threat['impactedGoal']}\n"
                    if threat.get('impactedAssets'):
                        content += f"- **Impacted Assets**: {threat['impactedAssets']}\n"
                    content += f"- **Priority**: {priority_title}\n"
                    content += f"- **Category**: {category}\n\n"
                    content += "---\n\n"
            
            # Write the formatted file
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return str(output_file)
            
        except Exception as e:
            self.logger.error(f"Error creating formatted threat file: {e}")
            return None
